1)
mkdir ~/work/os/lab_prog; cd ~/work/os/lab_prog

2)
touch calculate.h calculate.c main.c; ls
gedit calculate.c

#include <stdio.h>
#include <math.h>
#include <string.h>
#include "calculate.h"

float
Calculate(float Numeral, char Operation[4])
{
float SecondNumeral;
if(strncmp(Operation, "+", 1) == 0)
{
printf("Второе слагаемое: ");
scanf("%f",&SecondNumeral);
return(Numeral + SecondNumeral);
}
else if(strncmp(Operation, "-", 1) == 0)
{
printf("Вычитаемое: ");
scanf("%f",&SecondNumeral);
return(Numeral - SecondNumeral);
}
else if(strncmp(Operation, "*", 1) == 0)
{
printf("Множитель: ");
scanf("%f",&SecondNumeral);
return(Numeral * SecondNumeral);
}
else if(strncmp(Operation, "/", 1) == 0)
{
printf("Делитель: ");
scanf("%f",&SecondNumeral);
if(SecondNumeral == 0)
{
printf("Ошибка: деление на ноль! ");
return(HUGE_VAL);
}
else
return(Numeral / SecondNumeral);
}
else if(strncmp(Operation, "pow", 3) == 0)
{
printf("Степень: ");
scanf("%f",&SecondNumeral);
return(pow(Numeral, SecondNumeral));
}
else if(strncmp(Operation, "sqrt", 4) == 0)
return(sqrt(Numeral));
else if(strncmp(Operation, "sin", 3) == 0)
return(sin(Numeral));
else if(strncmp(Operation, "cos", 3) == 0)
return(cos(Numeral));
else if(strncmp(Operation, "tan", 3) == 0)
return(tan(Numeral));
else
{
printf("Неправильно введено действие ");
return(HUGE_VAL);
}
}

gedit main.c

#include <stdio.h>
#include "calculate.h"

int
main (void)
{
float Numeral;
char Operation[4];
float Result;
printf("Число: ");
scanf("%f",&Numeral);
printf("Операция (+,-,*,/,pow,sqrt,sin,cos,tan): ");
scanf("%s",&Operation);
Result = Calculate(Numeral, Operation);
printf("%6.2f\n",Result);
return 0;
}

gedit calculate.h

#ifndef CALCULATE_H_
#define CALCULATE_H_

float Calculate(float Numeral, char Operation[4]);

#endif /*CALCULATE_H_*/

3)
gcc -c calculate.c
gcc -c main.c
gcc calculate.o main.o -o calcul -lm

4)
(исправление файлов)

5)
touch Makefile; gedit Makefile

#
# Makefile
#

CC = gcc #компилятор
CFLAGS = -g #опция, которая отладочную информацию
LIBS = -lm
#Создаем файл calcul
calcul: calculate.o main.o # ниже добавляем опцию
gcc calculate.o main.o -o calcul $(LIBS)
#Создаем файл calculate.o
calculate.o: calculate.c calculate.h
gcc -c calculate.c $(CFLAGS)
#Создаем файл main.o
main.o: main.c calculate.h
gcc -c main.c $(CFLAGS)

clean: #очистка файлов указанного типи "o"
-rm calcul *.o *~

# End Makefile

6)
(исправление файлов)
gdb ./calcul
run
list
list 12,15
list calculate.c:20,29
list calculate.c:20,27
break 21
info breakpoints
run
5
-
backtrace
print Numeral
display Numeral
info breakpoints
delete 1

7)
sudo dnf install splint
splint calculate.c
splint main.c

ВОПРОСЫ:
1)
Дополнительную информацию об этих программах можно получить с помощью функций info и man.

2)
Unix поддерживает следующие основные этапы разработки приложений:

- создание исходного кода программы;

- представляется в виде файла;

- сохранение различных вариантов исходного текста;

- анализ исходного текста;

- компиляция исходного текста и построение исполняемого модуля;

- тестирование и отладка;

- проверка кода на наличие ошибок;

- сохранение всех изменений, выполняемых при тестировании и отладке.

Необходимо отслеживать изменения исходного кода, а также при работе более двух программистов над проектом программы нужно, чтобы они не делали изменений кода в одно время.

3)
Использование суффикса “.с” для имени файла с программой на языке Си отражает удобное и полезное соглашение, принятое в ОС UNIX. Для любого имени входного файла суффикс определяет какая компиляция требуется. Суффиксы и префиксы указывают тип объекта. Одно из полезных свойств компилятора Си — его способность по суффиксам определять типы файлов. По суффиксу ".c" компилятор распознает, что файл abcd.c должен компилироваться, а по суффиксу ".o", что файл "abcd.о" является объектным модулем и для получения исполняемой программы необходимо выполнить редактирование связей. Простейший пример командной строки для компиляции программы abcd.c и построения исполняемого модуля abcd имеет вид: "gcc -o abcd abcd.c". Некоторые проекты предпочитают показывать префиксы в начале текста изменений для старых и новых файлов. Опция – prefix может быть использована для установки такого префикса. Плюс к этому команда "bzr diff -p1" выводит префиксы в форме которая подходит для команды patch "-p1".

4)
Основное назначение компилятора с языка Си заключается в компиляции всей программы в целом и получении исполняемого модуля.

5)
При разработке большой программы, состоящей из нескольких исходных файлов заголовков, приходится постоянно следить за файлами, которые требуют перекомпиляции после внесения изменений. Программа make освобождает пользователя от такой рутинной работы и служит для документирования взаимосвязей между файлами. Описание взаимосвязей и соответствующих действий хранится в так называемом make-файле, который по умолчанию имеет имя makefile или Makefile.

6)
makefile для некой программы расщирения ".c" мог бы иметь вид:
```
# Makefile
CC = gcc
CFLAGS =
LIBS = -lm
calcul: calculate.o main.o
gcc calculate.o main.o -o calcul $(LIBS)
calculate.o: calculate.c calculate.h
gcc -c calculate.c $(CFLAGS)
main.o: main.c calculate.h
gcc -c main.c $(CFLAGS)
clean: -rm calcul *.o *~
# End Makefile
```

В общем случае make-файл содержит последовательность записей (строк), определяющих зависимости между файлами. Первая строка записи представляет собой список целевых (зависимых) файлов, разделенных пробелами, за которыми следует двоеточие и список файлов, от которых зависят целевые. Текст, следующий за точкой с запятой, и все последующие строки, начинающиеся с литеры табуляции, являются командами OC UNIX, которые необходимо выполнить для обновления целевого файла.

7)
Пошаговая отладка программ заключается в том, что выполняется один оператор программы и, затем контролируются те переменные, на которые должен был воздействовать данный оператор. Если в программе имеются уже отлаженные подпрограммы, то подпрограмму можно рассматривать, как один оператор программы и воспользоваться вторым способом отладки программ. Если в программе существует достаточно большой участок программы, уже отлаженный ранее, то его можно выполнить, не контролируя переменные, на которые он воздействует. Использование точек останова позволяет пропускать уже отлаженную часть программы. Точка останова устанавливается в местах, где необходимо проверить содержимое переменных или просто проконтролировать, передаётся ли управление данному оператору. Практически во всех отладчиках поддерживается это свойство (а также выполнение программы до курсора и выход из подпрограммы). Затем отладка программы продолжается в пошаговом режиме с контролем локальных и глобальных переменных, а также внутренних регистров микроконтроллера и напряжений на выводах этой микросхемы.

8)
- backtrace – выводит весь путь к текущей точке останова, то есть названия всех функций, начиная от main(); иными словами, выводит весь стек функций;

- break – устанавливает точку останова; параметром может быть номер строки или название функции;

- clear – удаляет все точки останова на текущем уровне стека (то есть в текущей функции);

- continue – продолжает выполнение программы от текущей точки до конца;

- delete – удаляет точку останова или контрольное выражение;

- display – добавляет выражение в список выражений, значения которых отображаются каждый раз при остановке программы;

- finish – выполняет программу до выхода из текущей функции; отображает возвращаемое значение,если такое имеется;

- info breakpoints – выводит список всех имеющихся точек останова;

- info watchpoints – выводит список всех имеющихся контрольных выражений;

- splist – выводит исходный код; в качестве параметра передаются название файла исходного кода, затем, через двоеточие, номер начальной и конечной строки;

- next – пошаговое выполнение программы, но, в отличие от команды step, не выполняет пошагово вызываемые функции;

- print – выводит значение какого-либо выражения (выражение передаётся в качестве параметра);

- run – запускает программу на выполнение;

- set – устанавливает новое значение переменной;

- step – пошаговое выполнение программы;

- watch – устанавливает контрольное выражение, программа остановится, как только значение контрольного выражения изменится.

9)
- Выполнили компиляцию программы;

- Увидели ошибки в программе;

- Открыли редактор и исправили программу;

- Загрузили программу в отладчик gdb run — отладчик выполнил программу, ввели требуемые значения;

- Программа завершена, gdb не видит ошибок.

10)
Отладчику не понравился формат "%s" для "&Operation", так как "%s" — символьный формат, а значит необходим только Operation.

11)
Если вы работаете с исходным кодом, который не вами разрабатывался, то назначение различных конструкций может быть не совсем понятным. Система разработки приложений UNIX предоставляет различные средства, повышающие понимание исходного кода. К ним относятся: cscope - исследование функций, содержащихся в программе; splint — критическая проверка программ, написанных на языке Си.

12)
Проверка корректности задания аргументов всех исполняемых функций , а также типов возвращаемых ими значений; Поиск фрагментов исходного текста, корректных с точки зрения синтаксиса языка Си, но малоэффективных с точки зрения их реализации или содержащих в себе семантические ошибки; Общая оценка мобильности пользовательской программы.